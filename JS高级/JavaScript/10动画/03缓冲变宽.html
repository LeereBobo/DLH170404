<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title></title>
		<style>
			div {
				width: 100px;
				height: 100px;
				background-color: red;
				margin-bottom:10px;
			}
		</style>
	</head>

	<body>
		
			<div></div>
			<div></div>
			<div></div>
			<div></div>
			<div></div>
			<div></div>
			<div></div>
			<div></div>
	
		<script type="text/javascript">
			var oDivs = document.getElementsByTagName("div");
			//var timer = 0;

			function startMove(obj, speed, iTarget) {
				clearInterval(obj.timer);
				obj.timer = setInterval(function() {
					var speedEnd = (iTarget - obj.offsetWidth) / speed;
					speedEnd = speedEnd > 0 ? Math.ceil(speedEnd) : Math.floor(speedEnd);
					if(iTarget == obj.offsetWidth) {
						clearInterval(timer);
					} else {
						console.log("可见宽度" + obj.offsetWidth + "speedEnd的值是" + speedEnd);
						obj.style.width = obj.offsetWidth + speedEnd + "px";
					}
				}, 20);
			}
			for(var i = 0; i < oDivs.length; i++) {
				//oDivs[i].timer = null;
				oDivs[i].onmouseover = function() {
					startMove(this, 10, 800);	
				}
				oDivs[i].onmouseout = function() {
					startMove(this, 10, 100);
				}
			}
			
			/*
			 当i=1时,1 的鼠标移入,执行函数,clearInterval(obj.timer);中的obj.timer没有被赋值,
			 默认为空
			 当i的鼠标移出的时候,执行函数clearInterval(obj.timer)中
			 obj.timer 为1鼠标移入的timer,直接清除
			 所以不用再遍历oDivs的时候给timer赋值
			 function startMove(obj, speed, iTarget) {
				clearInterval(timer);
				timer = setInterval(function() {
					var speedEnd = (iTarget - obj.offsetWidth) / speed;
					speedEnd = speedEnd > 0 ? Math.ceil(speedEnd) : Math.floor(speedEnd);
					if(iTarget == obj.offsetWidth) {
						clearInterval(timer);
					} else {
						console.log("可见宽度" + obj.offsetWidth + "speedEnd的值是" + speedEnd);
						obj.style.width = obj.offsetWidth + speedEnd + "px";
					}
				}, 20);
			}
			没有自定义属性的函数,效果不完美,执行顺序:
			i= 1时,鼠标移入,执行函数,开启定时器
			i= 1是,鼠标移出,执行函数,清除移入的定时器,开定时器
			i= 2时,鼠标移入,执行函数,清除1鼠标移出的定时器,开启2的移入的定时器,所以当2移入时,
			1的长度不会自动变窄,修改方法:加入自定属性
			 * */
		</script>
	</body>

</html>